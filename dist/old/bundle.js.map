{"version":3,"sources":["webpack:///webpack/bootstrap ae4559889416aa3fc441","webpack:///./src/core/constant.js","webpack:///./src/main.js","webpack:///./src/core/crypt/webcrypter.js","webpack:///./src/core/crypt/string2Buffer.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACRA;AACA;;AAEA;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AAAA;AAAA;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AAAA;AAAA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ae4559889416aa3fc441","const ua = navigator.userAgent.replace(/[\\.0-9]+/g,\"x\");\nconst domain = window.location;\nexport default {\n  dbName:\"ECIDBEM\",\n  ua:ua,\n  domain:domain,\n  iv:\"ECIDBEMivðŸš‰å‡ºãƒ™ãƒ \",\n  strechCount:10020\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/constant.js\n// module id = 0\n// module chunks = 0","import constant from './core/constant'\nimport Webcrypter from './core/crypt/webcrypter'\n\nlet webCrypter = WebCrypter();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/main.js\n// module id = 2\n// module chunks = 0","import constant from '../constant'\nimport String2Buffer from './string2Buffer'\nconst AES_CBC = \"AES-CBC\";\nconst scubtleCrypto = crypto.subtle;\nconst iv = crypto.getRandomValues(new Uint8Array(12));\nconst algorithm = {\n  name: AES_CBC,\n  iv: String2Buffer.s2b(constant.iv)\n};\nconst hashLevel = \"SHA-512\";\nexport default class WebCrypter {\n  constructor() {}\n  hash(dataString, salt1, salt2) {\n    return hashExecute(dataString, salt1, salt2, 0);\n  }\n  //ã€€ã‚¹ãƒˆãƒ¬ãƒƒãƒå›žæ•°åˆ†å›žã‚‹ã‚ˆï¼\n  hashExecute(dataString, salt1, salt2, count) {\n    let self = this\n    count++;\n    return new Promise((resolve, reject) => {\n      scubtleCrypto.digest(hashLevel, dataString).then((keyBuffer) => {\n        if (constant.strechCount > count) {\n          let nextDataString = salt1 + String2Buffer.b2Base64(keyBuffer) + salt2;\n          self.hashExecute(nextDataString, salt1, salt2, count)\n        } else {\n          resolve(String2Buffer.b2Base64(keyBuffer));\n        }\n      }, (e) => {\n        console.log(e);\n        reject(e);\n      })\n    });\n  }\n  //Data only String, you need JSON.stringify.\n  encrypt(key, dataString) {\n    return new Promise((resolve, reject) => {\n      scubtleCrypto.digest(hashLevel, key).then((keyBuffer) => {\n        //buffer is binary\n        let dataBuffer = String2Buffer.s2b(dataString);\n        scubtleCrypto.encrypt(algorithm, keyBuffer, dataBuffer).then((result) => {\n          resolve(result);\n        }, (e) => {\n          console.log(e);\n          reject(e);\n        });\n\n      }, (e) => {\n        console.log(e);\n        reject(e);\n      });\n    });\n  }\n  //\n  decrypt(key, cryptBuffer) {\n    return new Promise((resolve, reject) => {\n      scubtleCrypto.digest(hashLevel, key).then((keyBuffer) => {\n        //buffer is binary\n        scubtleCrypto.decrypt(algorithm, keyBuffer, cryptBuffer).then((result) => {\n          let resultString = String2Buffer.s2b(result);\n          resolve(resultString);\n        }, (e) => {\n          console.log(e);\n          reject(e);\n        });\n\n      }, (e) => {\n        console.log(e);\n        reject(e);\n      });\n    });\n  }\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/crypt/webcrypter.js\n// module id = 3\n// module chunks = 0","const size = 1024;\nexport default class String2Buffer {\n  // string to buffer\n  static s2b(str) {\n    let array = new Uint16Array([].map.call(str, (c) => {\n      return c.charCodeAt(0)\n    }));\n    return array.buffer;\n  }\n  // buffer to string\n  static b2s(buf) {\n    let tmp = [];\n    let bufLen = buf.byteLength;\n    for (let p = 0; p < bufLen; p += size) {\n      let currentBuf = buf.slice(p, p + size);\n      tmp.push(String.fromCharCode.apply(\"\", new Uint16Array(currentBuf)));\n    }\n    return tmp.join(\"\");\n  }\n  static base64Encode(str) {\n    return btoa(unescape(encodeURIComponent(str)));\n  }\n  static base64Dcode(str) {\n    return decodeURIComponent(escape(atob(str)));\n  }\n  // buffer to BASE64 string\n  static b2Base64( buffer ) {\n      let binary = '';\n      let bytes = new Uint8Array( buffer );\n      let len = bytes.byteLength;\n      for (let i = 0; i < len; i++) {\n          binary += String.fromCharCode( bytes[ i ] );\n      }\n      return window.btoa( binary );\n  }\n  // BASE64 string to buffer\n  static base642b(base64) {\n      let binary_string =  window.atob(base64);\n      let len = binary_string.length;\n      let bytes = new Uint8Array( len );\n      for (let i = 0; i < len; i++)        {\n          bytes[i] = binary_string.charCodeAt(i);\n      }\n      return bytes.buffer;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/crypt/string2Buffer.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}